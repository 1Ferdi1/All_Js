 ДЗ: добавить настройки для каждой фигуры отдельно, добавить сферу, бублик, чашку(по желанию). 



освещение
на сцене освещенность задается с помощью изменения цвета каждого отдельно взятого полигона
от его текущего цвета, до черного
то есть макс освещенность полигона соответствует его исходному цвету, а мин освещенность соответствует черному
освещенность полигона можно задавать несколькими способами
    1)словом в текстовой форме
    2)задание цвета в формате RGB
для определения цвета есть функция RGB в которую передается 3 значения 
с диапозоном значения [0-255] и каждый соответствует определенному насыщению цвета
'rgb(255,0,0)'

в 3д графике существует несколько типов источников света
    -точечный источник света(солнце, лампа)
    -поверхность
у нас будет точечный источник света

задание освещенности на сцене 
    -задается точечный источник света (статический или динамический)
    -для каждого кадра сцены вычисляется растояние от каждого полигона до источника света(в зависимости от мощности источника света, определяется освещенность полигода [0-1])
    -соответствующая освещенность умнож на каждый цвет в политре полигона, и полигон в этом цвете отрисовывается

Регулярные выражения - в жи ес Регулярные выражения- один из типов объектов который используется для поиска комбинаций символа в строках
чтобы записать ставится 1)/Вася/; 2)const l1=new RegExp('Вася');
у них есть методы 
    -l.test() - возвращает истину если строка содержит совпадения с заданным шаблоном рег выражения
    l.test('Какая-то строка');
символы и значения рег выражений
    - . соответствует любому одиночному символу за исключением символу переноса строки
    - * соответствует предидущему выражению которое повторено 0 или более раз
    - + соответствует предидущему выражению которое повторено 1 или более раз
    - ? соответствует предидущему выражению повторенному 0 или 1 раз
    - ^ соответствует началу строки
    - $ соответствует концу строки

группы символов
    \d - соответствует любому ...
    \w - соответствует любому символу 
    [XYZ] - набор символов соответствует любому одиночному символу из этого указанного набора(можно задавать диапозоны [a-z])
    [XYZ]+ - соответствует символу из скобок повторенному 1 или более раз
    [^A-Z] - внутри выражения задающих диапозоны символов ^ используется как знак отрицания

    g - глобальный поиск по строке
    i - поиск не чувствительный к регистру 

доп конструкции 
(x) - выражении соответствует x и запоминает это соответствие
(?:x) - выражение соответствует х но не запоминает соответствие
х(?=y) - соответствует х только если за ним соответствует у

используются в основном для валедации вводимых пользователем данных
валедация для почтовых ящиков, телефонных номеров
Регулярные выражения являются ресурсоемкими


class Polygon {
    constructor (points=[], color="#ffaa22"){
        this.points=points;
        this.color=this.hexToRgb(color);
        this.distance=0;
        this.lumen=1;
    }

    hexToRgb(hexColor){
        const result = /^#?([a-f\d]{2})
        ([a-f\d]{2}) ([a-f\d]{2})$\i.exed(hexColor);

        return result?{
            r:parseInt(result[1],16),
            g:parseInt(result[2],16),
            b:parseInt(result[3],16)}
            {r:0, g:0, b:0};
        }


    rgbToHex(r,g,b){return rgb(${r},${g}, ${b});}



    }
    //если разбиение выполнено успешно то в result будет записан массив из найденных по шаблону подстрок 

}


Источник света
Math3D->entities
class Light extends Point{
    constructor(x,y,z, lumen=1000){
        super(x,y,z);
        this.lumen=lumen;
    }
}



class Graph3D extends Component{
    constructor(){
        //
        this.LIGHT=new Light(-40,5,10,25000);
    }

    renderFrame(){
        this.Math3D.caleDistance(this.scene, this.LIGHT, 'lumen');
    }

    const lumen = this.Math3D.calcI1lumination(polygon.limen, this.LIGHT.lumen);
    let{r, g, b} = polygon.color;
    r=Math.round(r*lumen);
    g=Math.round(g*lumen);
    b=Math.round(b*lumen);
    this.canvas.polygon(array, polygon.rgbToHex(r, g, b));
}


class Math3D{
    calcI1lumination(distance, lumen){
        const illum=distance?lumen/distance**3:1;
        return illum>1?1:illum;
    }
}

основные поверхности второго порядка 
поверхности
-цилиндр гиперболический, параборлический, элипсический, однополосной гиперболоид, двуполосной гиперболоид, элипсоид, конус, сфера, элиптический параболоид, гиперболический параболоид